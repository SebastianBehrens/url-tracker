<svg id="world-map" style="width: 100%; height: 100%; display: block;"></svg>

<script>
    // Make the update function globally accessible
    window.updateMap = updateMap;

    // Get API key from parent window
    const API_KEY = window.parent.API_KEY;

    // Get dimensions from the parent container for proper sizing
    const container = d3.select("#map-container");
    const width = container.node().getBoundingClientRect().width;
    const height = container.node().getBoundingClientRect().height;

    const svg = d3.select("#world-map")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .style("display", "block");

    const projection = d3.geoMercator()
        .scale(width / 2 / Math.PI)
        .translate([width / 2, height / 2]);

    const initialScale = projection.scale();
    const initialTranslate = projection.translate();
    const pathGenerator = d3.geoPath().projection(projection);
    const g = svg.append("g");

    const lineGenerator = d3.line()
        .x(d => projection([d.lon, d.lat])[0])
        .y(d => projection([d.lon, d.lat])[1]);

    const tooltip = container.append("div")
        .attr("class", "tooltip")
        .style("position", "absolute")
        .style("z-index", "10")
        .style("visibility", "hidden")
        .style("background", "#121212")  // Changed to dark background
        .style("border", "1px solid hsl(var(--p))")
        .style("border-radius", "0.5rem")
        .style("padding", "1rem")
        .style("color", "#fe0075")  // Changed to match the trace color
        .style("box-shadow", "0 4px 6px -1px hsl(var(--n) / 0.3)")
        .style("top", "1rem")  // Position from top
        .style("right", "1rem")  // Position from right
        .style("max-width", "300px");  // Prevent tooltip from being too wide


    d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(worldData => {
        // Initial render of map
        renderMap(worldData);
        // Make renderMap globally accessible for theme changes
        window.renderMapWithData = () => renderMap(worldData);
    });

    function renderMap(worldData) {
        g.selectAll("path.country").remove();

        g.selectAll("path.country")
            .data(worldData.features)
            .enter()
            .append("path")
            .attr("class", "country")
            .attr("d", pathGenerator)
            .attr("fill", "hsl(var(--s) / 0.1)")
            .style("stroke", "hsl(var(--p))")
            .style("stroke-width", 0.5)
            .style("opacity", 0.8);
    }

    function updateMap(locations) {
        const transformedLocations = locations.map(loc => ({
            detected_at: loc[0], lat: loc[1], lon: loc[2], country: loc[3],
            city: loc[4], isp: loc[5], org: loc[6], as_number: loc[7]
        }))
        .filter(d => d.lat != null && d.lon != null)
        .sort((a, b) => new Date(a.detected_at) - new Date(b.detected_at));

        const countryPaths = g.selectAll("path.country");

        if (transformedLocations.length === 0) {
            projection.scale(initialScale).translate(initialTranslate);
        } else if (transformedLocations.length === 1) {
            const point = transformedLocations[0];
            projection
                .scale(1000)
                .translate([width / 2, height / 2])
                .center([point.lon, point.lat]);
        } else {
            const geoJsonData = {
                type: "FeatureCollection",
                features: transformedLocations.map(d => ({
                    type: "Feature",
                    geometry: { type: "Point", coordinates: [d.lon, d.lat] }
                }))
            };
            const padding = 50;
            projection.fitExtent([[padding, padding], [width - padding, height - padding]], geoJsonData);
        }

        const zoomTransition = d3.transition().duration(750);
        countryPaths.transition(zoomTransition).attr("d", pathGenerator);

        updateTraceAndPoints(transformedLocations);
    }

    // Replace the calculateLabelPosition function with this improved version
    function calculateLabelPosition(point, index, locations, width, height) {
        const margin = 50;
        const labelDistance = 30;
        
        // Get projected points for previous and next locations
        const prevPoint = index > 0 ? projection([locations[index - 1].lon, locations[index - 1].lat]) : null;
        const nextPoint = index < locations.length - 1 ? projection([locations[index + 1].lon, locations[index + 1].lat]) : null;
        
        // Calculate path direction if we have either prev or next point
        let pathAngle = 0;
        if (prevPoint && nextPoint) {
            // We're in the middle of the path
            pathAngle = Math.atan2(nextPoint[1] - prevPoint[1], nextPoint[0] - prevPoint[0]);
        } else if (prevPoint) {
            // We're at the end of the path
            pathAngle = Math.atan2(point[1] - prevPoint[1], point[0] - prevPoint[0]);
        } else if (nextPoint) {
            // We're at the start of the path
            pathAngle = Math.atan2(nextPoint[1] - point[1], nextPoint[0] - point[0]);
        }

        // Place label perpendicular to the path direction
        // Choose the side that's facing away from the center of the map
        const centerX = width / 2;
        const centerY = height / 2;
        const fromCenter = {
            x: point[0] - centerX,
            y: point[1] - centerY
        };

        // Calculate perpendicular angles (both directions)
        const perp1 = pathAngle + Math.PI / 2;
        const perp2 = pathAngle - Math.PI / 2;

        // Test which perpendicular direction points more away from center
        const test1 = {
            x: Math.cos(perp1),
            y: Math.sin(perp1)
        };
        const test2 = {
            x: Math.cos(perp2),
            y: Math.sin(perp2)
        };

        // Dot product with vector from center to determine which direction points more outward
        const dot1 = test1.x * fromCenter.x + test1.y * fromCenter.y;
        const dot2 = test2.x * fromCenter.x + test2.y * fromCenter.y;

        // Choose the angle that points more away from center
        let angle = dot1 > dot2 ? perp1 : perp2;

        // Edge case handling
        if (point[1] < margin) {  // Near top edge
            angle = Math.PI / 2;  // Force downward
        } else if (point[1] > height - margin) {  // Near bottom edge
            angle = -Math.PI / 2;  // Force upward
        }

        // Add slight variation based on index to prevent exact overlaps
        const variation = (index % 2 === 0 ? 1 : -1) * Math.PI / 12;  // Â±15 degrees
        angle += variation;

        return {
            x: point[0] + Math.cos(angle) * labelDistance,
            y: point[1] + Math.sin(angle) * labelDistance,
            textX: point[0] + Math.cos(angle) * (labelDistance + 5),
            textY: point[1] + Math.sin(angle) * (labelDistance + 5),
            angle: angle
        };
    }

    function updateTraceAndPoints(locations) {
        g.selectAll("circle").remove();
        g.selectAll("path.trace-segment").remove();
        g.selectAll(".point-label").remove();  // Add this line to clean up old labels

        if (locations.length === 0) {
            return;
        }

        const durationPerSegment = 700;

        // Add points
        g.selectAll("circle")
            .data(locations)
            .enter()
            .append("circle")
            .attr("cx", d => projection([d.lon, d.lat])[0])
            .attr("cy", d => projection([d.lon, d.lat])[1])
            .attr("r", 0)
            .style("fill", "hsl(var(--p))")
            .style("stroke", "hsl(var(--s))")
            .style("stroke-width", 1.5)
            .style("opacity", 0.9)
            .on("mouseover", (event, d) => tooltip.style("visibility", "visible")
                .html(`
                    <strong>${d.city || 'N/A'}, ${d.country || 'N/A'}</strong>
                    <div style="display: grid; grid-template-columns: max-content max-content; gap: 0.5rem 0; margin-top: 0.5rem;">
                        <div style="text-align: right;">ISP:</div>
                        <div style="text-align: left;">${d.isp}</div>
                        <div style="text-align: right;">Detected:</div>
                        <div style="text-align: left;">${new Date(d.detected_at).toLocaleString()}</div>
                    </div>
                `))
            .on("mouseout", () => tooltip.style("visibility", "hidden"))
            .transition()
            .delay((d, i) => i * durationPerSegment)
            .duration(250)
            .attr("r", 5);

        // Add labels with connecting lines
        const labelGroup = g.selectAll(".point-label")
            .data(locations)
            .enter()
            .append("g")
            .attr("class", "point-label")
            .style("opacity", 0);

        // Add connecting lines
        labelGroup.append("line")
            .style("stroke", "hsl(var(--p))")
            .style("stroke-width", 1)
            .attr("x1", d => projection([d.lon, d.lat])[0])
            .attr("y1", d => projection([d.lon, d.lat])[1])
            .attr("x2", (d, i) => {
                const point = projection([d.lon, d.lat]);
                const pos = calculateLabelPosition(point, i, locations, width, height);
                return pos.x;
            })
            .attr("y2", (d, i) => {
                const point = projection([d.lon, d.lat]);
                const pos = calculateLabelPosition(point, i, locations, width, height);
                return pos.y;
            });

        // Add number labels
        labelGroup.append("text")
            .attr("x", (d, i) => {
                const point = projection([d.lon, d.lat]);
                const pos = calculateLabelPosition(point, i, locations, width, height);
                return pos.textX;
            })
            .attr("y", (d, i) => {
                const point = projection([d.lon, d.lat]);
                const pos = calculateLabelPosition(point, i, locations, width, height);
                return pos.textY;
            })
            .style("fill", "hsl(var(--p))")
            .style("font-size", "12px")
            .style("font-weight", "bold")
            .style("text-anchor", "middle")
            .style("dominant-baseline", "middle")
            .text((d, i) => i + 1);

        // Animate labels
        labelGroup.transition()
            .delay((d, i) => i * durationPerSegment)
            .duration(250)
            .style("opacity", 1);

        // Continue with existing trace path code
        if (locations.length < 2) {
            return;
        }

        for (let i = 0; i < locations.length - 1; i++) {
            const segmentData = [locations[i], locations[i + 1]];

            const segmentPath = g.append("path")
                .attr("class", "trace-segment")
                .attr("d", lineGenerator(segmentData))
                .style("fill", "none")
                .style("stroke", "#fe0075") // Active trace color
                .style("stroke-width", 2)
                .style("opacity", 0.9);

            const length = segmentPath.node().getTotalLength();

            segmentPath
                .attr("stroke-dasharray", length + " " + length)
                .attr("stroke-dashoffset", length)
                .transition()
                    .delay(i * durationPerSegment)
                    .duration(durationPerSegment)
                    .ease(d3.easeLinear)
                    .attr("stroke-dashoffset", 0)
                    // When the transition ends, change the color to black
                    .on("end", function() {
                        d3.select(this)
                          .transition()
                          .duration(500) // Optional: fade to black smoothly
                          .style("stroke", "black");
                    });
        }

        tooltip.style("background", "#121212")  // Changed to dark background
               .style("border", "1px solid hsl(var(--p))")
               .style("color", "#fe0075")  // Changed to match the trace color
               .style("box-shadow", "0 4px 6px -1px hsl(var(--n) / 0.3)");
    }
</script>